module ShortCut.Modules.Busco
  where

import Development.Shake
import ShortCut.Core.Types
import ShortCut.Core.Paths (cacheDir, toCutPath, fromCutPath, exprPath)
import ShortCut.Core.Actions (debugA, writeLits, runCmd, CmdDesc(..))
import ShortCut.Core.Compile.Basic (defaultTypeCheck, rExpr, mkLoad, rSimple)
import ShortCut.Modules.SeqIO (faa)
import ShortCut.Modules.BlastDB (aFilterList)
import System.FilePath (takeDirectory, takeBaseName, (<.>), (</>))
import System.Directory           (createDirectoryIfMissing)
import ShortCut.Core.Util         (resolveSymlinks)
import System.Exit (ExitCode(..))

cutModule :: CutModule
cutModule = CutModule
  { mName = "Busco"
  , mDesc = "Benchmarking Universal Single-Copy Orthologs"
  , mTypes = [lin, faa]
  , mFunctions =
      [ loadLineage
      , buscoListLineages
      , buscoFetchLineage
      , buscoProteins
      -- [ buscoGenome -- TODO remove until augustus is packaged?
      -- , buscoTranscriptome
      -- TODO each versions
      ]
  }

lin :: CutType
lin = CutType
  { tExt  = "lin"
  , tDesc = "BUSCO lineage" -- TODO call it something better like database?
  , tShow = \c _ f -> do
      f' <- liftIO $ resolveSymlinks (Just $ cfgTmpDir c) f
      return $ "BUSCO lineage file '" ++ f' ++ "'"
  }

loadLineage :: CutFunction
loadLineage = mkLoad False "load_lineage" lin

buscoCache :: CutConfig -> CutPath
buscoCache cfg = cacheDir cfg "busco"

buscoGenome        = undefined
buscoTranscriptome = undefined

-------------------------
-- busco_list_lineages --
-------------------------

buscoListLineages :: CutFunction
buscoListLineages = CutFunction
  { fName      = name
  , fTypeCheck = defaultTypeCheck [str] (ListOf str)
  , fTypeDesc  = mkTypeDesc name  [str] (ListOf str)
  , fDesc      = Nothing
  , fFixity    = Prefix
  , fRules     = rBuscoListLineages
  }
  where
    name = "busco_list_lineages"

rBuscoListLineages :: RulesFn
rBuscoListLineages s@(_, cfg, ref, ids) e@(CutFun _ _ _ _ [f]) = do
  (ExprPath fPath) <- rExpr s f
  let fPath' = toCutPath   cfg fPath
  listTmp %> \_ -> aBuscoListLineages   cfg ref ids lTmp'
  oPath'  %> \_ -> aFilterList cfg ref ids oPath lTmp' fPath'
  return (ExprPath oPath')
  where
    oPath   = exprPath s e
    tmpDir  = buscoCache cfg
    tmpDir' = fromCutPath cfg tmpDir
    listTmp = tmpDir' </> "dblist" <.> "txt"
    oPath'  = fromCutPath cfg oPath
    lTmp'   = toCutPath   cfg listTmp
rBuscoListLineages _ _ = fail "bad argument to rBuscoListLineages"

aBuscoListLineages :: CutConfig -> Locks -> HashedSeqIDsRef -> CutPath -> Action ()
aBuscoListLineages cfg ref _ listTmp = do
  liftIO $ createDirectoryIfMissing True tmpDir
  writeLits cfg ref oPath allLineages
  where
    listTmp' = fromCutPath cfg listTmp
    tmpDir   = takeDirectory $ listTmp'
    oPath    = debugA cfg "aBuscoListLineages" listTmp' [listTmp']
    -- These seem static, but may have to be updated later.
    -- The list is generated by "Download all datasets" on the homepage
    allLineages =
      [ "bacteria_odb9"
      , "proteobacteria_odb9"
      , "rhizobiales_odb9"
      , "betaproteobacteria_odb9"
      , "gammaproteobacteria_odb9"
      , "enterobacteriales_odb9"
      , "deltaepsilonsub_odb9"
      , "actinobacteria_odb9"
      , "cyanobacteria_odb9"
      , "firmicutes_odb9"
      , "clostridia_odb9"
      , "lactobacillales_odb9"
      , "bacillales_odb9"
      , "bacteroidetes_odb9"
      , "spirochaetes_odb9"
      , "tenericutes_odb9"
      , "eukaryota_odb9"
      , "fungi_odb9"
      , "microsporidia_odb9"
      , "dikarya_odb9"
      , "ascomycota_odb9"
      , "pezizomycotina_odb9"
      , "eurotiomycetes_odb9"
      , "sordariomyceta_odb9"
      , "saccharomyceta_odb9"
      , "saccharomycetales_odb9"
      , "basidiomycota_odb9"
      , "metazoa_odb9"
      , "nematoda_odb9"
      , "arthropoda_odb9"
      , "insecta_odb9"
      , "endopterygota_odb9"
      , "hymenoptera_odb9"
      , "diptera_odb9"
      , "vertebrata_odb9"
      , "actinopterygii_odb9"
      , "tetrapoda_odb9"
      , "aves_odb9"
      , "mammalia_odb9"
      , "euarchontoglires_odb9"
      , "laurasiatheria_odb9"
      , "embryophyta_odb9"
      , "protists_ensembl"
      , "alveolata_stramenophiles_ensembl"
      ]

------------------------
-- busco_fetch_lineage --
------------------------

-- TODO consistent naming with similar functions

buscoFetchLineage :: CutFunction
buscoFetchLineage  = CutFunction
  { fName      = name
  , fTypeCheck = defaultTypeCheck [str] lin
  , fTypeDesc  = mkTypeDesc name  [str] lin
  , fDesc      = Nothing
  , fFixity    = Prefix
  , fRules     = rBuscoFetchLineage
  }
  where
    name = "busco_fetch_lineage"

-- TODO also have to untar it in the lineages dir
-- TODO and then might as well show dataset.cfg
rBuscoFetchLineage :: RulesFn
rBuscoFetchLineage st expr = (fRules loadLineage) st $ withBuscoUrl expr

-- TODO rename to just load_lineage?
-- TODO should the urls say v3 now? homepage still lists v2
withBuscoUrl :: CutExpr -> CutExpr
withBuscoUrl (CutFun rtn salt deps name [CutLit r s lineage])
  =          (CutFun rtn salt deps name [CutLit r s url])
  where
    url = "http://busco.ezlab.org/v2/datasets/" ++ lineage ++ ".tar.gz"
withBuscoUrl e = error $ "bad argument to withBuscoUrl: " ++ show e

-------------------------------------------
-- busco_{genome,proteins,transcriptome} --
-------------------------------------------

buscoProteins :: CutFunction
buscoProteins  = CutFunction
  { fName      = name
  , fTypeCheck = defaultTypeCheck [lin, faa] lin -- TODO busco results type
  , fTypeDesc  = mkTypeDesc name  [lin, faa] lin -- TODO busco results type
  , fDesc      = Nothing
  , fFixity    = Prefix
  , fRules     = rSimple aBuscoProteins
  }
  where
    name = "busco_proteins"

-- TODO need to generate + pass in the unique config file
-- TODO need to pass only the basename prefix of the outpath?
aBuscoProteins :: CutConfig -> Locks -> HashedSeqIDsRef -> [CutPath] -> Action ()
aBuscoProteins cfg ref ids [outPath, linPath, faaPath] = do
  let mode = "prot" -- TODO make this an arg
      out' = fromCutPath cfg outPath
      lin' = fromCutPath cfg linPath
      cDir = fromCutPath cfg $ buscoCache cfg
      -- lDir = cDir </> "lineages"
      -- lDir  = takeDirectory lin'
      -- lBase = takeBaseName lin'
      faa' = fromCutPath cfg faaPath
  liftIO $ createDirectoryIfMissing True $ fromCutPath cfg $ buscoCache cfg
  -- need [lin']
  runCmd cfg ref $ CmdDesc
    { cmdBinary = "busco.sh"
    , cmdArguments = [out', faa', lin', mode, cDir] -- TODO cfgtemplate, tdir
    , cmdFixEmpties = False
    , cmdParallel = False -- TODO fix shake error and set to True
    , cmdInPatterns = [faa'] -- TODO lineage file
    , cmdOutPath = out'
    , cmdExtraOutPaths = []
    , cmdSanitizePaths = []
    , cmdOptions = []
    , cmdExitCode = ExitSuccess
    , cmdRmPatterns = [out']
    }
